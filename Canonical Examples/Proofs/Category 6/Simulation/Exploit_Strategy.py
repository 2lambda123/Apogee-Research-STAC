#MIT License
#
#Copyright (c) 2017 Apogee Research
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.


import numpy as np
import operator
import math


def my_round(x, base=5):
    return int(base * round(float(x) / base))


# Calculate intersection point of two distributions
def calc_intersection(u_1, s_1, u_2, s_2):
    if s_1 != s_2:
        a = (s_2 ** 2 - s_1 ** 2)
        b = 2 * (u_2 * s_1 ** 2 - u_1 * s_2 ** 2)
        c = u_1 ** 2 * s_2 ** 2 - u_2 ** 2 * s_1 ** 2
        d = 2 * s_2 ** 2 * s_1 ** 2 * ((s_2 / s_1).ln())
        const = c - d
        t_1 = (-b + (b ** 2 - 4 * a * const).sqrt()) / (2 * a)
        t_2 = (-b - (b ** 2 - 4 * a * const).sqrt()) / (2 * a)
        return max(t_1, t_2)
    elif u_1 != u_2:
        return min(u_1, u_2) + abs(u_1 - u_2) / 2
    return 1000000


# Calculate the threshold value for char n
def calc_threshold(n, delta, sigma, attack_input):
    if n == 1:
        u1 = attack_input["u_2"]
        s1 = attack_input["s_2"]
    else:
        u1 = (n - 1) * delta
        s1 = ((n - 1) * (sigma ** 2)).sqrt()
    u2 = n * delta
    s2 = (n * (sigma ** 2)).sqrt()
    return calc_intersection(u1, s1, u2, s2)


# Determine appropriate distribution to sample from
def find_t_n(guess, password):
    # Determine number of correct chars, n
    n = 0
    for i in range(len(guess)):
        if guess[i] != password[i]:
            break
        n += 1
    return n


# Use number of correct chars thus far to generate time
# from appropriate distribution
def sample(guess, password, delta, sigma):
    n = find_t_n(guess, password)

    # With value of n draw random sample from t_n
    u = n * delta
    s = (n * (sigma ** 2)).sqrt()
    if s != 0:
        return np.random.normal(u, s)
    else:
        return u


def threshold_max_hist(password, max_ops, alphabet, delta, sigma, attack_input):
    guess = ""
    operations = 0
    M = 10
    sample_history = {}
    transitions = 0
    while operations < max_ops:
        transitions += 1
        # Current guess chars
        n = len(guess) + 1

        # Calculate entropy and probability of success
        n_prime = len(guess)
        m = find_t_n(guess, password)

        # Intersection t_n and t_n-1
        th_n = calc_threshold(n, delta, sigma, attack_input)
        # Sample chars in alphabet
        chosen_chars = []
        for char in alphabet:
            operations += 1
            # If we are on the last character
            if n == M:
                # print("\tGuessing", char, guess+char, guess+char == password)
                # If we guess correct then exit loop
                if guess + char == password:
                    chosen_chars.append((char, 0))
                    break
            else:
                time_char = sample(guess + char, password, delta, sigma)

                # Track previous samples
                if guess + char in sample_history:
                    sample_history[guess + char].append(time_char)
                else:
                    sample_history[guess + char] = [time_char]

                # Use previous history
                meantime_char = np.mean(sample_history[guess + char])

                # If threshold is exceeded the exit loop
                if meantime_char >= th_n:
                    chosen_chars.append((char, meantime_char))
            if operations >= max_ops:
                break

        # Check if any chars were chosen
        if len(chosen_chars) > 0:
            chosen_chars.sort(key=operator.itemgetter(1), reverse=True)
            chosen_char = chosen_chars[0][0]
            guess = guess + chosen_char
            # We have the password and are done
            if n == M:
                break
        # No chars were chosen so back up
        else:
            # Back up 1 char and try again
            if len(guess) > 1:
                guess = guess[:-1]

    return [operations, guess == password, transitions]
