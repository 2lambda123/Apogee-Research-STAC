package com.ainfosec.MalwareAnalyzer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.TreeMap;
import java.util.List;
import java.util.Map;
import java.util.regex.*;

public class DasmHelpers
{	
	/**
	 * Build a Dasm object from the lines of an "objdump -d" disassembly of a PE32 binary executable
	 * @param lines Disassembly lines
	 * @return Internal representation of disassembly
	 */
	public static Dasm build_dasm(String[] lines)
	{
		// Initialize X86 helper lists
		X86.initialize();
		
		// Parse the lines to internal instruction representations
		List<String> dasm_lines = Arrays.asList(lines);
		TreeMap<Integer, String> instruction_map = parse_instructions(dasm_lines);
		
		// Discard instructions that weren't decoded properly
		instruction_map = discard_badly_decoded_instructions(instruction_map);
		
		// Get set of all function entry point virtual addresses represented in the supplied disassembly
		Set<Integer> eps = get_function_entrypoints(instruction_map);
		
		// Construct a control flow graph for each function in the disassembly
		Set<CFG> cfgs = make_function_cfgs(instruction_map, eps);
		
		// Build a feature from the disassembly's opcode mnemonics
		Map<String, Integer> mnem_counts = count_opcode_mnemonics(instruction_map);
		int fv[] = generate_mnemonic_feature_vector(mnem_counts);
		
		// Instantiate a new Dasm object to represent the user-supplied disassembly.
		return new Dasm(cfgs, fv);
	}   
    
    /**
     * Generates an ordered map of X86 instructions from an "objdump -d <filename.exe>" command
     * @param dasm_lines The lines of an objdump dissassembly of a PE32 executable binary.
     * @return Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     */
    private static TreeMap<Integer, String> parse_instructions(List<String> dasm_lines)
    {
    	TreeMap<Integer, String> instructions = new TreeMap<Integer, String>();
        for(String l : dasm_lines)
        {
   		 	int address = 0;
   		 	String instr_dasm = "";
   		 	
   		 	// Regex matches: leading whitespace, a hex VA group-named 'address', whitespace, a sequence of one or
   		 	// more space-separated hex bytes, whitespace, a disassembled X86 instruction group-named 'instr' 
   		 	Pattern p = Pattern.compile("\\s*(?<address>[0-9a-fA-F]+):\\s+(?:[0-9a-fA-F]{2} )+\\s*(?<instr>\\S.*)");        	
        	 Matcher m = p.matcher(l);
        	 if(m.matches())
        	 {
        		 // Extract instruction's VA as integer
        		 address = Integer.parseInt(m.group("address"), 16);
        		 
        		 // Extract disassembled instruction as string
        		 instr_dasm = m.group("instr");
        		 
        		 // Remove all but one space in instruction's disassembly
        		 instr_dasm = instr_dasm.trim().replaceAll(" +", " ");
        		 
        		 // Map VA to Dasm
        		 instructions.put(address, instr_dasm);
        	 }
        }
        return instructions;
    }
    
    /**
     * Compute the set of function entrypoints represented in the disassembly.
     * An entrypoint is an address targeted by a Call instruction. 
     * @param instr_map Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     * @return Set of entrypoint VAs, as integers.
     */
    private static Set<Integer> get_function_entrypoints(Map<Integer, String> instr_map)
    {
    	Set<Integer> eps = new HashSet<Integer>();
    	
    	// iterate over each instruction
    	for (String instr_dasm : instr_map.values())
    	{
    		// Regex pattern matches a call instruction with direct target, with target group-named to 'targetaddr'
    	    Pattern p = Pattern.compile("call 0x(?<targetaddr>[0-9a-zA-Z]+)");
    	    Matcher m = p.matcher(instr_dasm);
    	    if(m.matches())
    	    {
    	    	// Extract direct call's target address and add to entry point set.
    	    	String target = m.group("targetaddr");
    	    	eps.add(Integer.parseInt(target, 16));
    	    }
    	}
    	return eps;    	
    }
        
    /**
     * Removes objdump 'bad' instructions and empty # labeled lines from the instruction map.
     * @param instr_map Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     * @return Input map, minus any badly decoded instructions.
     */
    private static TreeMap<Integer, String> discard_badly_decoded_instructions(TreeMap<Integer, String> instr_map)
    {
    	TreeMap<Integer, String> revised = new TreeMap<Integer, String>();
    	for (Map.Entry<Integer, String> entry : instr_map.entrySet())
    	{
    	    Integer addr = entry.getKey();
    	    String instr_dasm = entry.getValue();
    	    
    	    // Discard bad instructions or instructions recorded as just an integer
    	    if(!instr_dasm.equals("(bad)") && !instr_dasm.matches("[0-9]+"))
    	    {
    	    	revised.put(addr, instr_dasm);
    	    }
    	}
    	return revised;    	
    }    
    
    /**
     * Construct a map containing a map from opcode mnemonic to the count of that mnemonic seen in the input file.
     * @param instr_map Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     * @return Map from X86 mnemonic as string to count of said mnemonic as int
     */
    private static Map<String, Integer> count_opcode_mnemonics(Map<Integer, String> instr_map)
    {
    	Map<String, Integer> mnem_counts = new TreeMap<String, Integer>();
    	for (String instr_dasm : instr_map.values())
    	{
    		// Truncate disassembled instruction to just it's opcode mnemonic
    		String mnemonic = strip_arguments(instr_dasm);
    		
    		// If it's already in the map, bump the count by one
    		if(mnem_counts.containsKey(mnemonic))
    		{
    			int old_count = mnem_counts.get(mnemonic);
    			mnem_counts.put(mnemonic, old_count + 1);
    		}
    		else // else add it to the map with a count of one.
    		{
    			mnem_counts.put(mnemonic, 1);
    		}
    	}    	
    	return mnem_counts;
    }
    
    /**
     * Truncate operands off a disassembled instruction
     * @param instruction Disassembled instruction as string
     * @return Input instruction's opcode mnemonic
     */
    private static String strip_arguments(String instruction)
    {
    	// Truncate everything past first space
    	int iend = instruction.indexOf(' ');
    	if(iend != -1)
    	{
    		return instruction.substring(0, iend);
    	}
    	return instruction;
    }
          
    /**
     * Extract an operand from a disassembled X86 instruction
     * @param instruction Disassembled instruction
     * @param operand_index Index of operand to extract, counting from 0
     * @return The extracted operand if it exists, or null if it doesn't exist
     */
    private static String get_operand(String instruction, int operand_index)
    {
    	// Enforce that operand index must be at least 0
    	if(operand_index < 0)
    	{
    		return null;
    	}
    	
    	// If instruction has no operands, then bail out
    	int space_count = instruction.length() - instruction.replace(" ", "").length();
    	if(space_count == 0)
    	{
    		return null;
    	}
    	
    	// Get operand portion of instruction strings; i.e., everything after the last space
    	String args = instruction.substring(instruction.lastIndexOf(' ') + 1).trim();
    	
    	// Regex pattern matches a comma that is not enclosed in parentheses
    	Pattern non_enclosed_comma = Pattern.compile(",(?![^(]*\\))");
    	Matcher m = non_enclosed_comma.matcher(args);
    	
    	// Count the number of such commas
    	int comma_count = 0;
    	while(m.find())
    	{
    		comma_count++;
    	}
    	
    	// Bail out if instruction didn't have enough operands
    	if(operand_index > comma_count)
    	{
    		return null;
    	}
	    
    	// Strip off all operands preceding the one requested
    	int current_arg = 0;
    	while(current_arg < operand_index)
    	{
    			Matcher m1 = non_enclosed_comma.matcher(args);
    			m1.find();
    			int index_of_next_comma = m1.start();
    			args = args.substring(index_of_next_comma + 1);
    			current_arg++;
    	}
    	
    	// Strip off all operands found after the one requested
    	Matcher m2 = non_enclosed_comma.matcher(args);
    	if(m2.find())
    	{    	
	    	int index_of_next_comma = m2.start();
	    	args = args.substring(0, index_of_next_comma);
    	}
    	
    	return args;
    }
    
    
    /**
     * Determine whether a branch instruction's target is direct (or indirect).
     * @param target Instruction's target operand as string
     * @return true if target is direct, else false
     */
    private static boolean target_is_direct(String target)
    {
    	// A direct target operand is a hex VA not preceded by an asterisk
    	return target.matches("^0x.*$");
    }
    
    /**
     * Construct the control flow graph for each function in the supplied disassembly.
     * @param instr_map Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     * @param entry_points List of function entry points as integer encoded VA's in the disassembly
     * @return Set of all control flow graphs represented in the disassembly
     */
    private static Set<CFG> make_function_cfgs(TreeMap<Integer, String> instr_map, Set<Integer> entry_points)
    {
    	Set<CFG> cfgs = new HashSet<CFG>();    	
    	for(Integer ep : entry_points)
    	{
    		CFG cfg = make_function_cfg(instr_map, ep);
    		cfgs.add(cfg);
    	}
    	
    	return cfgs;
    }
    
    /**
     * Construct a control flow graph for a particular function
     * @param instr_map Map from Virtual Address of instruction to X86 (dis)assembly instruction.
     * @param entry_point Entry point of the function for which to construct the control flow graph
     * @return The function's control flow graph
     */
    private static CFG make_function_cfg(TreeMap<Integer, String> instr_map, Integer entry_point)
    {
    	// Create a blank CFG
    	CFG cfg = new CFG(entry_point);
    	
    	// Worklist of to-be-processed basic blocks, specified by their VA entry points.
    	Queue<Integer> key_queue = new LinkedList<Integer>();
    	
    	// Add the first instruction of the function to the worklist
    	key_queue.add(entry_point);
    	
    	// Stores the entry-points of already processed basic blocks.  We check against this set
    	// prior to adding a new basic block's EP to the worklist to prevent infinite loops.
    	Set<Integer> seen = new HashSet<Integer>();
    	seen.add(entry_point);
    	
    	// Stores the set of instructions (by VA) that have already been assigned to some basic block.
    	// We use this to ensure that no instructions can get cacscaded into multiple different blocks,
    	// which Invincia took advantage of at E3 to trigger an unintended AC space vulnerability.
    	Set<Integer> assigned_instructions = new HashSet<Integer>();
		
    	// While worklist contains entries
		while(!key_queue.isEmpty())
		{
			// Pop entry from queue
			Integer block_ep = key_queue.poll();
			
			// Ordered list of (VA, DASM) pairs found in the present block
			List<Map.Entry<Integer, String>> block_instructions = new ArrayList<Map.Entry<Integer, String>>();
			
			// VA's of the instructions to which control may flow after execution of the presently considered basic block
			Set<Integer> successors = new HashSet<Integer>();
			
			// Get the first validly decoded instruction beyond the specified block entry point
			Map.Entry<Integer, String> current_instruction = instr_map.ceilingEntry(block_ep);
			while(current_instruction != null)
			{
				// Go no further if the current instruction has already been added to some other basic block.
				if(assigned_instructions.contains(current_instruction.getKey()))
				{
					// However, if we already added some previously instructions to this basic block, set the block's successor to
					// the block that already contains the current instruction.
					if(!block_instructions.isEmpty())
					{
						successors.add(current_instruction.getKey());
					}
					break;
				}
				
				// Add instruction to the block's instruction list
				block_instructions.add(current_instruction);
				
				// Record that this VA's instruction has been recorded in some basic block 
				assigned_instructions.add(current_instruction.getKey());				
				
				// Check if block concluded with a conditional jump
				String ci_mnem = strip_arguments(current_instruction.getValue());
				if(X86.is_a_conditional_jump(ci_mnem))
				{
					// if so, get jump's target and if it's not indirect then add it to the worklist queue, successors, and seen
					String target = get_operand(current_instruction.getValue(), 0);
					if(target_is_direct(target))
					{
						int target_int = Integer.decode(target);
						successors.add(target_int);
						if(!seen.contains(target_int))
						{
							key_queue.add(target_int);
							seen.add(target_int);
						}
					}
					
					//also add the instruction's immediate successor to the queue since it was a conditional branch
					Map.Entry<Integer, String> next_entry = instr_map.higherEntry(current_instruction.getKey());
					if(next_entry != null && !seen.contains(next_entry.getKey()))
					{
						key_queue.add(next_entry.getKey());
						successors.add(next_entry.getKey());
						seen.add(next_entry.getKey());
					}
					break;
				}
				
				// If the block is concluded by a 'jmp', then add the target to worklist if it's direct
				if(X86.is_a_unconditional_jump(ci_mnem))
				{
					// get target and if it's not indirect then add it to the queue
					String target = get_operand(current_instruction.getValue(), 0);
					if(target_is_direct(target))
					{
						int target_int = Integer.decode(target);
						if(!seen.contains(target_int))
						{
							key_queue.add(target_int);
							successors.add(target_int);
							seen.add(target_int);
						}
					}
					break;
				}
				
				// If the block is concluded by a call
				if(X86.is_a_call(ci_mnem))
				{
					// add the immediate successor to the block entry point queue
					Map.Entry<Integer, String> next_entry = instr_map.higherEntry(current_instruction.getKey());
					if(next_entry != null && !seen.contains(next_entry.getKey()))
					{
						key_queue.add(next_entry.getKey());
						successors.add(next_entry.getKey());
						seen.add(next_entry.getKey());
					}
					
					// record that this function calls the targeted function
					String target = get_operand(current_instruction.getValue(), 0);
					if(target_is_direct(target))
					{
						int target_int = Integer.decode(target);
						cfg.add_call_target(target_int);
					}
					
					break;
				}
				
				// A ret instruction terminates a basic block
				if(X86.is_a_ret(ci_mnem))
				{
					break;
				}
				
				// Current instruction didn't conclude the present basic block, so grab the next one.
				current_instruction = instr_map.higherEntry(current_instruction.getKey());
			}			
			
			// If there were new instructions with which to create a new basic block, then do so and add it to the CFG.
			if(!block_instructions.isEmpty())
			{
				cfg.add_block(new BasicBlock(block_instructions, successors));
			}
		}
		return cfg;
    }
    
    /**
     * Build a feature vector from the disassembly's opcode mnemonics, using the mapping in X86.java.
     * @param mnem_counts Mapping from opcode mnemonic to count of said mnemonic seen in the disassembly.
     * @return Feature vector
     */
    private static int[] generate_mnemonic_feature_vector(Map<String, Integer> mnem_counts)
    {
    	int fv[] = new int[665];
    	for(Map.Entry<String, Integer> entry : mnem_counts.entrySet())
    	{
    		String mnem = entry.getKey();
    		int count = entry.getValue();
    		Integer fv_index = X86.get_mnemonic_fv_index(mnem);
    		if(fv_index != null)
    		{
    			fv[fv_index] = count;
    		}
    	}
    	return fv;
    }    
}
