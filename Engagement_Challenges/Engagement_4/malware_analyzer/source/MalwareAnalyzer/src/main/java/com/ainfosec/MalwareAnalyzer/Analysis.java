package com.ainfosec.MalwareAnalyzer;

public class Analysis {
	
	// Heuristic thresholds, empirically determined.
	private static int byte_average_threshold = 95;
	private static double byte_entropy_threshold = 6.55;
		
	/**
	 * Determines where the input file characterized by a supplied feature vector is packed.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @return true if the input file was packed, or false if it was not packed or if the input feature vector is malformed.
	 */
	public static boolean is_packed(int[] fv)
	{		
		int byte_average = compute_average_byte(fv);
		double byte_entropy = compute_byte_entropy(fv);
	
		// Check if feature vector exceeds heuristic thresholds.
		if((byte_average > byte_average_threshold) && (byte_entropy > byte_entropy_threshold))
		{
			return true;
		}
		return false;
	}
	
	/**
	 * Wraps tail recursive method for computing average byte value in a feature vector.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @return The average byte value.
	 */
	private static int compute_average_byte(int[] fv)
	{
		// Call recursive averaging method, starting from first index into fv, and with empty count and sum accumulators.
		return compute_average_byte_helper(fv, 0, 0, 0);
	}	
	
	/**
	 * Computes the average byte value denoted by a feature vector.  Tail recursive.
	 * @param fv The feature vector.
	 * @param count_acc Accumulated count of bytes consumed from fv.
	 * @param sum_acc Accumulated sum of bytes consumed from fv.
	 * @param step The current index of fv to be consumed. Auto-increments on each recursive call, and recursion stops when step surpasses 0xFF.
	 * @return Average byte value.
	 */
	private static int compute_average_byte_helper(int[] fv, int count_acc, int sum_acc, int step)
	{
		// Compute and return average = (sum / count) once the entire feature vector has been consumed. 
		if(step > 0xFF)
		{
			return sum_acc / count_acc; // STAC: Divide by zero happens here.
		}

		// Otherwise, if the entire feature vector has yet to be consumed, bump the count and sum, then recurse.
		int new_count = count_acc + fv[step];
		int new_sum = sum_acc + (step * fv[step]);		
		return compute_average_byte_helper(fv, new_count, new_sum, step + 1);
	}
	
	/**
	 * Wraps tail recursive method for computing entropy from a feature vector.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @return Byte-level entropy of the input file characterized by feature vector fv.
	 */
	private static double compute_byte_entropy(int[] fv)
	{
		// Get total count of bytes input file characterized by fv
		int count_of_bytes = count_bytes(fv);
		
		// Call recursive entropy calculation method, starting from first index into fv, and with empty entropy accumulator.
		return compute_byte_entropy_helper(fv, count_of_bytes, 0, 0);
	}
	
	/**
	 * Computes the byte-level entropy of an input file characterized by a supplied feature vector.  Tail recursive.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @param byte_count The total number of bytes denoted by feature vector fv.
	 * @param ent_acc Accumulated entropy of the already consumed portion of the feature vector.
	 * @param step The current index of fv to be consumed. Auto-increments on each recursive call, and recursion stops when step surpasses 0xFF.
	 * @return Byte-level entropy of the input file characterized by feature vector fv.
	 */
	private static double compute_byte_entropy_helper(int[] fv, int byte_count, double ent_acc, int step)
	{
		// Compute and return entropy once the entire feature vector has been consumed. 
		if(step > 0xFF)
		{
			return -ent_acc;
		}
		
		// Otherwise, if the entire feature vector has yet to be consumed, accumulate the additional entropy due to the current step.	
		double new_ent;
		if(fv[step] > 0) // If the byte step was present in the input file, then it adds to the entropy.
		{
			double prob = (double)fv[step] / byte_count;
			new_ent = ent_acc + prob * (Math.log(prob) / Math.log(2));
		}
		else
		{
			new_ent = ent_acc;
		}

		// Recurse onto next step.
		return compute_byte_entropy_helper(fv, byte_count, new_ent, step + 1);
	}
	
	/**
	 * Wraps tail recursive method for computing total number of bytes in the input file characterized by the supplied feature vector.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @return Total number of bytes in input file characterized by fv.
	 */
	private static int count_bytes(int[] fv)
	{
		// Call recursive byte counter method, starting from first index into fv, and with an empty count accumulator.
		return count_bytes_helper(fv, 0, 0);
	}
	
	/**
	 * Count the total number of bytes in the file file characterized by the supplied feature vector.  Tail recursive.
	 * @param fv A feature vector of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @param count_acc Accumulated count of bytes denoted by the already consumed portion of the feature vector.
	 * @param step The current index of fv to be consumed. Auto-increments on each recursive call, and recursion stops when step surpasses 0xFF.
	 * @return Total number of bytes in input file characterized by fv.
	 */
	private static int count_bytes_helper(int[] fv, int count_acc, int step)
	{
		// Return accumulated count if entire feature vector has been consumed.
		if(step > 0xFF)
		{
			return count_acc;
		}
		
		// Otherwise, accumulate and recurse onto the next step.
		return count_bytes_helper(fv, count_acc + fv[step], step + 1);
	}

	/**
	 * Wraps tail recursive method for computing the cosine similarity between two malware samples.
	 * @param s1 The first sample.
	 * @param s2 The second sample.
	 * @return Cosine similarity between the two malware samples.
	 */
	public static double compute_cosine_similarity(Sample s1, Sample s2)
	{	
		// There are 0xFF different byte values
		return Analysis.compute_cosine_similarity_helper(s1.get_fv(), s2.get_fv(), 0, 0, 0, 0, 0xFF);
	}
	
	/**
	 * Wraps tail recursive method for computing the cosine similarity between two malware disassemblies.
	 * @param s1 The first disassembly.
	 * @param s2 The second disassembly.
	 * @return Cosine similarity between the two malware disassemblies.
	 */
	public static double compute_cosine_similarity(Dasm s1, Dasm s2)
	{	
		// There are 664 different support X86 opcode mnemonics, see X86.java.
		return Analysis.compute_cosine_similarity_helper(s1.getFv(), s2.getFv(), 0, 0, 0, 0, 664);
	}

	/**
	 * Computes the cosine similarity between two feature vectors.
	 * @param fv1 The first feature vector, of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @param fv2 The second feature vector, of length 256 for which the value at index X denotes the number of X bytes in the input file.
	 * @param dp_acc Accumulated dot product.
	 * @param fv1_sos_acc Accumulated sum of squares for first feature vector.
	 * @param fv2_sos_acc Accumulated sum of squares for second feature vector.
	 * @param step The current index of fv to be consumed. Auto-increments on each recursive call, and recursion stops when step surpasses 0xFF.
	 * @param num_steps Number of expected elements in the feature vectors fv1 and fv2.
	 * @return Cosine similarity of two feature vectors.
	 */
	private static double compute_cosine_similarity_helper(int[] fv1, int[] fv2, long dp_acc, long fv1_sos_acc, long fv2_sos_acc, int step, int num_steps)
	{
		// Compute and return cosine similarity = dotproduct(fv1,fv2) / (magnitude(fv1) * magnitude(fv2))
		// once the feature vectors have been consumed. 
		if(step > num_steps)
		{
			return (double)dp_acc / (Math.sqrt(fv1_sos_acc) * Math.sqrt(fv2_sos_acc));
		}
		
		// Otherwise, if the feature vectors have yet to be fully consumed, accumulate the dot product and magnitude contributes for the step, then recurse.
		long new_dp_acc = dp_acc + ((long)fv1[step] * fv2[step]);
		long new_fv1_sos_acc = (long) (fv1_sos_acc + Math.pow(fv1[step], 2));
		long new_fv2_sos_acc = (long) (fv2_sos_acc + Math.pow(fv2[step], 2));		
		return compute_cosine_similarity_helper(fv1, fv2, new_dp_acc, new_fv1_sos_acc, new_fv2_sos_acc, step + 1, num_steps);
	}
}
