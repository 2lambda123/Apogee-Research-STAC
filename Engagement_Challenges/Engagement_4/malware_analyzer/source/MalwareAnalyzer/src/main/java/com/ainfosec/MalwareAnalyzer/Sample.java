package com.ainfosec.MalwareAnalyzer;

/**
 * Internal representation of a malware sample submitted to the server via an add HTTP request.
 */
public class Sample
{
	// This sample's feature vector; i.e., an integer array length 256 for which the value at index X denotes the number of X bytes in the input file.
	private final int [] fv;
	
	// This sample is thought to be packed?
	private final Boolean is_packed;
	
	/**
	 * Constructor
	 * @param _fv Feature vector for the new Sample, ostensibly submitted via an HTTP add request. 
	 */
	public Sample(String _fv)
	{
		fv = new int[256];
		
		// Split CSV input format
		String[] feature_counts = _fv.trim().split(",");
		
		if(feature_counts.length != 256)
		{
			throw new IllegalArgumentException("Malformed feature vector CSV.\n");
		}
		
		Boolean input_is_empty = true; // Used to check if supplied feature vector corresponds to an empty input file (which is disallowed).
		
		// For each byte count in the supplied feature vector
		for(int ii=0; ii <= 0xFF; ii++)
		{
			// Parse the supplied count to an int
			// throws NumberFormatException if datum is unparseable.
			fv[ii] = Integer.parseInt(feature_counts[ii]);
			
			if(fv[ii] < 0)
			{
				throw new IllegalArgumentException("Illegal feature count, 0x" + Integer.toHexString(ii) + " = " + feature_counts[ii] + "\n");
			}
			
			if(fv[ii] != 0)
			{
				// Then the feature vector corresponds to a non-empty file.
				input_is_empty = false;
			}
		}
		
		if(input_is_empty)
		{
			throw new IllegalArgumentException("Feature vector contains no features.\n");
		}
		
		// Determine whether feature vector corresponds to a packed malware binary.
		is_packed = Analysis.is_packed(fv);
	}
	
	/**
	 * Serialize this Sample's feature vector to CSV
	 * @return CSV string representation of internal feature vector.
	 */
	public String serialize_fv()
	{
		boolean first = true;
		String serialized = "";
		for(int f : fv)
		{
			if(!first)
			{
				serialized += ",";
			}
			serialized += Integer.toString(f);
			first = false;
		}
		return serialized;
	}	
	
	/**
	 * Getter for feature vector
	 * @return Sample's feature vector.
	 */
	public int[] get_fv()
	{
		return fv;
	}
	
	/**
	 * Getter for is_packed
	 * @return is_packed
	 */
	public Boolean is_packed()
	{
		return is_packed;
	}
}
