package com.ainfosec.MalwareAnalyzer;

import java.io.IOException;
import java.lang.NumberFormatException;
import java.net.URLDecoder;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Set;

import fi.iki.elonen.NanoHTTPD;

/**
 * HTTP server.  Listens for add and query requests from the user.
 */
public class Server extends NanoHTTPD
{
	
	// Holds server's response to a request
	private static String response;
	
	/**
	 * Constructor
	 * @param p Port on which to listen
	 * @throws IOException
	 */
	public Server(int p) throws IOException
	{
		super(p);
		
		// Start the server
		start(NanoHTTPD.SOCKET_READ_TIMEOUT, false);
		System.out.println("Server started, running on port " + p);		
		response = "";
	}
	
	/**
	 * Generates a CSV feature vector from binary data
	 * @param input Binary data from which to generate a feature vector.
	 * @return CSV feature vector.
	 */
	public static String featurize(byte[] input)
	{
		int[] counts = new int[256];
		for(byte b : input)
		{
			// primitive byte is signed, this promotes to int and masks off the sign bit.
			int unsigned = (int)b & 0xff;
			counts[unsigned]++;
		}
		
		String fv_csv = "";
		Boolean first = true;
		for(int c : counts)
		{
			if(!first)
			{
				fv_csv += ",";
			}
			fv_csv += c;
			first = false;
		}
		
		return fv_csv;
	}
	
	/**
	 * Computes the MD5 checksum of data stored in a byte array.
	 * @param input Byte array of input data
	 * @return Input array's MD5 checksum
	 * @throws NoSuchAlgorithmException
	 * @throws IOException
	 */
	private static byte[] createChecksum(byte[] input) throws NoSuchAlgorithmException, IOException
	{
		InputStream fis =  new ByteArrayInputStream(input);
	
		byte[] buffer = new byte[1024];
		MessageDigest complete = MessageDigest.getInstance("MD5");
		int numRead;
	
		do
		{
			numRead = fis.read(buffer);
			if (numRead > 0)
			{
				complete.update(buffer, 0, numRead);
			}
		} while (numRead != -1);
	
		fis.close();
		return complete.digest();
	}
	
	/**
	 * Generates the MD5 digest of data stored in a byte array.
	 * @param input Byte array of input data
	 * @return Input array's MD5 digest as a String
	 * @throws NoSuchAlgorithmException
	 * @throws IOException
	 */
	public static String getMD5Checksum(byte[] input) throws NoSuchAlgorithmException, IOException
	{
		byte[] b = createChecksum(input);
		String result = "";
	
		for (int i=0; i < b.length; i++)
		{
			result += Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );
		}
		return result;
	}
	
	/* (non-Javadoc)
	 * @see fi.iki.elonen.NanoHTTPD#serve(fi.iki.elonen.NanoHTTPD.IHTTPSession)
	 */
	@Override
	public Response serve(IHTTPSession session)
	{
		// Open log file to record last response.
		Logger.initialize("response.log");
	
		// Get the POST body from the HTTP request. 
		Map<String, String> files = new HashMap<String, String>();
		Method method = session.getMethod();
		
		// HTTP POST supports Add request via CSV feature vector, and also Query request.
	    if (Method.POST.equals(method))
	    {
	        try
	        {
	            session.parseBody(files);
	        }
	        catch (IOException ioe)
	        {
	        	return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
	        }
	        catch (ResponseException re)
	        {
	        	return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, re.getMessage());
	        }
	        
		    String body = session.getQueryParameterString();
		    try {
				body = URLDecoder.decode(body, "UTF-8");
			} catch (UnsupportedEncodingException e1) {
				return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, "COULD NOT DECODE MESSAGE\n");
			}
		    
		    // Break the POST body into lines
		    String lines[] = body.split("\\r?\\n");

		    switch(lines[0])
		    {
		    
		    	///////////////////////////
		    	// QUERY REQUEST         //
		    	///////////////////////////
			    case "query":
			    	
			    	if(lines.length != 2)
			    	{
			    		response = "Could not parse input request\n";
			    		break;
			    	}
			    	
			    	String query_sample_md5 = lines[1];
			    	Sample query_sample = Database.get_sample_by_md5(query_sample_md5);
			    	if(query_sample == null)
			    	{
			    		response = "The supplied MD5 does not correspond to any sample in the database.\n";
			    		break;
			    	}
		
			    	// Compute the cosine similarity between the requested sample and every other sample in the database.
			    	NavigableSet<ComparisonResult> results = Database.compute_all_similarities(query_sample_md5);
			    	
			    	// Construct the response, containing information about the top five most similar.
			    	response = "Querying " + query_sample_md5 + " " + (query_sample.is_packed() ? "(Packed)" : "(Not Packed)") + "\n";
			    	response += "Top Five Most Similar:\n";
					int ii = 0;
					String feature_vector_output = "";
					for(ComparisonResult cr : results.descendingSet())
					{
						// Skip the query sample
						if(cr.get_md5().equals(query_sample_md5))
						{
							continue;
						}
						
						if(ii > 4) // Break after 5 results
						{
							break;
						}
						ii++;
						
						Sample s = Database.get_sample_by_md5(cr.get_md5());
						String packed_status = (s.is_packed() ? "(Packed)" : "(Not Packed)");
						response += String.format("%s - Score: %.3f %s\n", cr.get_md5(), cr.get_score(), packed_status);
						
						feature_vector_output += String.format("%s = {%s}\n", cr.get_md5(), s.serialize_fv());  
					}
					response += "\n" + feature_vector_output;
			    	break;
		    	
		    	///////////////////////////
		    	// ADD REQUEST           //
		    	///////////////////////////
			    case "add":
			    	
			    	if(lines.length != 3)
			    	{
			    		response = "Could not parse input request\nWrong number of lines for an add request.\n";
			    		break;
			    	}	    	
			    	
			    	String new_sample_md5 = lines[1];
			    	if(new_sample_md5.length() != 32)
			    	{
			    		response = "Could not parse input request\nBad MD5.\n";
			    		break;
			    	}
			    	
			    	// If sample has not been previously submitted, then add it to database.
			    	if(Database.is_unknown(new_sample_md5))
			    	{
				    	try
				    	{
				    		Database.see(new_sample_md5); // Add new sample to set of previously seen.
				    		Sample new_sample = new Sample(lines[2]); // Construct a new Sample from the supplied feature vector.  STAC: Malicious input causes ArithmeticException (div. by zero) to be thrown.
					    	Database.add_sample(new_sample_md5, new_sample); // Add it to the database.
				    	}
				    	catch (Exception e)
				    	{
				    		if(e instanceof NumberFormatException)
				    		{
					    		response = "Could not parse input request\nUnparseable data in supplied feature vector\n";
					    		break;			    			
				    		}
				    		else if(e instanceof IllegalArgumentException)
				    		{
					    		response = "Could not parse input request\n" + e.toString() + "\n";
					    		break;
				    		}
				    		else
				    		{
					    		StringWriter sw = new StringWriter();
					    		PrintWriter pw = new PrintWriter(sw);
					    		e.printStackTrace(pw);
					    		response += "Could not parse input request\n" + sw.toString() + "\n"; // STAC: Appends stack trace!
					    		break;
				    		}
				    		
				    	}
				    	
				    	response = "OK\n";
				    	break;
			    	}
			    	else
			    	{
			    		response = "Already known\n";
			    		break;
			    	}
			    	
		    	///////////////////////////
		    	// ADD_DASM REQUEST      //
		    	///////////////////////////
			    case "add_dasm":
			    	if(lines.length <= 3)
			    	{
			    		response = "Could not parse input request\nNot enough lines for an add_dasm request.\n";
			    		break;
			    	}
			    	
			    	String new_dasm_md5 = lines[1];
			    	if(new_dasm_md5.length() != 32)
			    	{
			    		response = "Could not parse input request\nBad MD5.\n";
			    		break;
			    	}
			    	
			    	// Check if dasm has previously been uploaded
			    	if(DasmDatabase.get_dasm(new_dasm_md5) != null)
			    	{
			    		response = "Already known\n";
			    		break;
			    	}
			    	
			    	// Find the start of the disassembly by searching for a valid objdump PE32 disassembly header in the first few lines of the input.
			    	int start_of_disassembly = -1;
			    	for(int jj = 2; jj <= 5; jj++)
			    	{
			    		if(lines[jj].contains("pei-i386"))
			    		{
			    			start_of_disassembly = jj;
			    		}
			    	}
			    	
			    	// If a valid disassembly was found, then extract it from the rest of the POST request.
			    	String dasm_lines[];
			    	if(start_of_disassembly != -1)
			    	{
			    		dasm_lines = Arrays.copyOfRange(lines, start_of_disassembly, lines.length);
			    	}
			    	else
			    	{
			    		response = "Could not parse input request\nDoes not appear to be an objdump disassembly of a PE32.\nUse \"objdump -d <input_exe>\"";
			    		break;
			    	}
			    	
			    	// Create a new Dasm from the input
			    	Dasm new_dasm = DasmHelpers.build_dasm(dasm_lines);
			    	
			    	// And add it the database of Dasms
			    	DasmDatabase.add_dasm(new_dasm_md5, new_dasm);
			    	response = "OK\n";
			    	break;
			    	
		    	///////////////////////////
		    	// LIST_DASMS REQUEST    //
		    	///////////////////////////
			    case "list_dasms":
			    	if(lines.length != 1)
			    	{
			    		response = "Malformed list_dasms request\n";
			    		break;
			    	}
			    	
			    	Set<String> md5s = DasmDatabase.get_all_dasm_md5s();
			    	
			    	response = "";
			    	for(String md5 : md5s)
			    	{
			    		response += md5 + "\n";
			    	}
			    	break;
		    	
		    	/////////////////////////////////////////
		    	// GET_FUNCTION_ENTRYPOINTS REQUEST    //
		    	/////////////////////////////////////////
			    case "get_function_entrypoints":
			    	if(lines.length != 2)
			    	{
			    		response = "Malformed get_function_entrypoints request\n";
			    		break;
			    	}
			    	String desired_md5 = lines[1];
			    	if(desired_md5.length() != 32)
			    	{
			    		response = "Malformed MD5\n";
			    		break;
			    	}
			    	Dasm dasm = DasmDatabase.get_dasm(desired_md5);
			    	if(dasm == null)
			    	{
			    		response = "Unknown MD5\n";
			    		break;
			    	}
			    	
			    	// Generate response listing the entry points of all the functions in the user-specified Dasm
			    	Set<CFG> cfgs = dasm.getCfgs();
			    	response = "";
			    	for(CFG cfg : cfgs)
			    	{
			    		response += "0x" + Integer.toHexString(cfg.getEntrypoint()) + "\n";
			    	}
			    	break;
			    	
		    	///////////////////////////
		    	// GET_CFG REQUEST       //
		    	///////////////////////////
			    case "get_cfg":
			    	if(lines.length != 3)
			    	{
			    		response = "Malformed get_cfg request\n";
			    		break;
			    	}
			    	String cfg_md5 = lines[1];
			    	if(cfg_md5.length() != 32)
			    	{
			    		response = "Malformed MD5\n";
			    		break;
			    	}
			    	
			    	// Decode user-specified function entry point to an int
			    	Integer ep;
			    	try
			    	{
			    		ep = Integer.decode(lines[2]);
			    	}
			    	catch(NumberFormatException e)
			    	{
			    		response = "Could not decode desired function entry point.\n";
			    		break;
			    	}
			    	
			    	// Get the requested Dasm
			    	Dasm cfg_dasm = DasmDatabase.get_dasm(cfg_md5);
			    	
			    	// Get the requested CFG from the Dasm
			    	CFG cfg = cfg_dasm.getCFG(ep);
			    	if(cfg == null)
			    	{
			    		response = "Requested function does not exist.\n";
			    		break;
			    	}
			    	
			    	// For each basic block, generate a response listing both its instructions and successors.
			    	response = "";
			    	for(BasicBlock block : cfg.get_all_blocks())
			    	{
			    		List<Map.Entry<Integer, String>> instructions = block.getInstructions();
			    		for(Map.Entry<Integer, String> instr : instructions)
			    		{
			    			int va = instr.getKey();
			    			String op = instr.getValue();
			    			response += "0x" + Integer.toHexString(va) + " : " + op + "\n";
			    		}
			    		response += "SUCCESSORS: ";
			    		for(Integer succ : block.getSuccessors())
			    		{
			    			response += "0x" + Integer.toHexString(succ) + ",";
			    		}
			    		response += "\n-----\n";
			    	}
			    	break;
			    
		    	///////////////////////////
		    	// QUERY_DASMS REQUEST   //
		    	///////////////////////////
			    case "query_dasms":
			    	if(lines.length != 2)
			    	{
			    		response = "Malformed query_dasms request\n";
			    		break;
			    	}
			    	String query_md5 = lines[1];
			    	if(query_md5.length() != 32)
			    	{
			    		response = "Malformed MD5";
			    		break;
			    	}
			    	
			    	Dasm query_dasm = DasmDatabase.get_dasm(query_md5);
			    	if(query_dasm == null)
			    	{
			    		response = "Desired disassembly does not exist.";
			    		break;
			    	}
			    	
			    	// Compute the cosine similarity between the requested dasm and every other dasm in the dasm database.
			    	NavigableSet<ComparisonResult> dasm_results = DasmDatabase.compute_all_similarities(query_md5);
			    	
			    	// Construct the response, containing information about the top five most similar.
			    	response = "Querying " + query_md5 + "\n";
			    	response += "Top Five Most Similar:\n";
					int kk = 0;

					for(ComparisonResult cr : dasm_results.descendingSet())
					{						
						if(kk > 4) // Break after 5 results
						{
							break;
						}
						kk++;
						response += String.format("%s - Score: %.3f\n", cr.get_md5(), cr.get_score());
					}
					response += "\n";
			    	break;

			    	
		    	///////////////////////////
		    	// BAD REQUEST           //
		    	///////////////////////////
			    default:
			    	response = "Could not parse input request\n";
			    	break;
		    }
	    }
	    
	    // PUT request is an Add request with binary input, rather than a user-supplied CSV feature vector.
	    else if(Method.PUT.equals(method))
	    {
	    	// Get length of PUT body
	    	Integer contentLength = Integer.parseInt(session.getHeaders().get("content-length"));
	    	
	    	byte[] buffer = new byte[contentLength];
	    	String new_sample_md5, fv_csv;
	    	
	    	try
	    	{
	    		// Read PUT body into buffer.
				session.getInputStream().read(buffer, 0, contentLength);
				
				new_sample_md5 = getMD5Checksum(buffer);
				
				// Generate CSV feature vector of counts from PUT body.
				fv_csv = featurize(buffer);
			}
	    	catch (Exception e) // I think this would only be thrown in the case where the HTTP request's content-length field specifies a value larger than the size of the actually supplied data.
			{
	    		return newFixedLengthResponse(Response.Status.INTERNAL_ERROR, MIME_PLAINTEXT, "Error handling HTTP request.\n");
			}
	    	
	    	// If sample has not been previously submitted, then add it to database.
	    	if(Database.is_unknown(new_sample_md5))
	    	{
		    	try
		    	{
		    		Database.see(new_sample_md5); // Add new sample to set of previously seen.
		    		Sample new_sample = new Sample(fv_csv); // Construct a new Sample from the supplied feature vector.
			    	Database.add_sample(new_sample_md5, new_sample); // Add it to the database.
		    	}
		    	catch (Exception e)
		    	{
		    		response = "Error, malformed binary input.";
		    	}
		    	
		    	response = "OK\n";
	    	}
	    	else
	    	{
	    		response = "Already known\n";
	    	}	    	
	    }
	    
	    // Any HTTP request other than POST or PUT is unsupported.
	    else
	    {
	    	response = "Unsupported HTTP request type.\n";
	    }
	    
	    // Write last response to the log file.
	    Logger.write_log_entry(response);
	    Logger.close_log();
	    
	    // Return response to the requester via HTTP.  16,000 characters should be enough to accommodate all non-malicious responses.
	    return newFixedLengthResponse(Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response.substring(0, Math.min(response.length(), 16000)));
	}
}
